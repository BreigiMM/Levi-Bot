package de.breigindustries.cs.bot.chatgpt;

import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import de.breigindustries.cs.bot.Levi;
import net.dv8tion.jda.api.entities.Guild;
import net.dv8tion.jda.api.entities.Member;
import net.dv8tion.jda.api.entities.Message;
import net.dv8tion.jda.api.entities.User;
import net.dv8tion.jda.api.entities.channel.ChannelType;
import net.dv8tion.jda.api.entities.channel.concrete.Category;
import net.dv8tion.jda.api.entities.channel.concrete.TextChannel;
import net.dv8tion.jda.api.entities.channel.unions.MessageChannelUnion;
import net.dv8tion.jda.api.events.message.MessageReceivedEvent;

public class Conversation {

    private static final Logger logger = LoggerFactory.getLogger(Conversation.class);

    // Keep track of ongoing conversations, key is the channelId
    private static Map<Long, Conversation> conversations = new HashMap<>();
    public static Conversation getConversationByMessageReceivedEvent(MessageReceivedEvent event) {
        Conversation conversation = conversations.get(event.getChannel().getIdLong());
        if (conversation != null) return conversation;

        conversation = createEmptyConversationFromMessageReceivedEvent(event);
        
        conversations.put(event.getChannel().getIdLong(), conversation);
        return conversation;
    }
    private static Map<Long, Conversation> ephemeralConversations = new HashMap<>();
    public static Conversation getEphemeralConversationByMessageReceivedEvent(MessageReceivedEvent event) {
        Conversation conversation = conversations.get(event.getChannel().getIdLong());
        if (conversation != null) return conversation;

        conversation = createEmptyConversationFromMessageReceivedEvent(event);

        ephemeralConversations.put(event.getChannel().getIdLong(), conversation);
        return conversation;
    }

    // Hold the channel for newly created objects, so that the reply is easily sent
    private MessageChannelUnion channel;
    private MessageChannelUnion getChannelEntity() { return channel; }
    private Conversation setChannelEntity(MessageChannelUnion channel) {
        this.channel = channel;
        return this;
    }

    private final long channelId;
    /** If this is not in a guild, it holds {@value -1} */
    private final long guildId;
    private long lastMsgTimestamp;
    private final List<ConversationEntry> messages;
    private final boolean isPrivate;

    // Store historical channel, category and guild names for efficient and offline queueing
    private String channelName;
    private String categoryName;
    private String guildName;

    /**
     * Creates a new conversation from a channel.
     * Private, as new conversations are automatically generated by the finder method
     * @param channelId
     * @param guildId
     * @param lastMsgTimestamp
     * @param isPrivate
     * @param channelName Current name of the channel
     * @param categoryName Current name of the category the channel is in
     * @param guildName Current Server of the server
     */
    private Conversation(long channelId, long guildId, long lastMsgTimestamp, boolean isPrivate, String channelName, String categoryName, String guildName) {
        this.channelId = channelId;
        this.guildId = guildId;
        this.lastMsgTimestamp = lastMsgTimestamp;
        this.isPrivate = isPrivate;
        this.channelName = channelName;
        this.categoryName = categoryName;
        this.guildName = guildName;

        this.messages = new ArrayList<>();
    }

    public void addEntryFromMessage(Message message) {
        String nickname = getNicknameOfUser(message.getAuthor());
        messages.add(new ConversationEntry(message, nickname));
    }

    private String getNicknameOfUser(User author) {
        // If this proves uneffective, we could queue the guild to be fetched at object creation
        String name = author.getEffectiveName(); // fallback
        Guild guild = Levi.getJDA().getGuildById(guildId);
        if (guild == null) {
            return name;
        }

        Member member = guild.getMember(author);
        if (member == null) {
            return name;
        }

        String nickname = member.getNickname();
        if (nickname == null) {
            return name;
        }

        logger.info("Nickname " + nickname + " found for user " + name + "!");
        return nickname;
    }

    /**
     * Sets the {@link de.breigindustries.cs.chatgpt.Conversation#lastMsgTimestamp Last Message Timestamp} to 0, possibly to prevent Levi from replying
     * without explicit mention.
     */
    public void resetLastMsgTimer() {
        lastMsgTimestamp = 0;
    }

    public int size() {
        return messages.size();
    }

    public long getChannelId() { return channelId; }
    /**
     * Returns the id of the guild this conversation happens in
     * @return guild ID or -1 if this was not in a guild
     */
    public long getGuildId() { return guildId; }
    public long getLastMsgTimestamp() { return lastMsgTimestamp; }
    public List<ConversationEntry> getMessages() { return messages; }
    public boolean isPrivate() { return isPrivate; }
    public String getChannelName() { return channelName; }
    public String getCategoryName() { return categoryName; }
    public String getGuildName() { return guildName; }

    public static Conversation createEmptyConversationFromMessageReceivedEvent(MessageReceivedEvent event) {
        MessageChannelUnion channel = event.getChannel();
        String categoryName = "No Category";
        String guildName = "No Guild";
        long guildId = -1;
        if (channel instanceof TextChannel textChannel) { // Is set to only reply in DMs and text channels (see Levi.shouldReply)
            Category category = textChannel.getParentCategory();
            if (category != null) categoryName = category.getName();
            Guild guild = event.getGuild();
            guildName = guild.getName();
            guildId = guild.getIdLong();
        }
        return new Conversation(
            channel.getIdLong(),
            guildId,
            System.currentTimeMillis(),
            channel.getType() == ChannelType.PRIVATE,
            channel.getName(),
            categoryName,
            guildName).setChannelEntity(channel);
    }

    public static CompletableFuture<Conversation> fillConversation(Conversation conversation, int messageLimit) {
        
        CompletableFuture<Conversation> future = new CompletableFuture<>();
        
        // Fetch the channel by id
        MessageChannelUnion channel = conversation.getChannelEntity();
        if (channel == null) {
            // Channel could not be found (might not have been "cached" according to ChatGPT)
            future.completeExceptionally(new RuntimeException("Could not find the channel of the conversation"));
            logger.error("Could not find the channel of the conversation!");
            return future;
        }

        // Fetch the history
        channel.getHistory().retrievePast(messageLimit).queue(messages -> {
            Collections.reverse(messages);
            for (int i = 0; i < messages.size(); i++) {
                Message msg = messages.get(i);
                ConversationEntry entry = new ConversationEntry(msg, conversation.getNicknameOfUser(msg.getAuthor()));
                conversation.getMessages().add(entry);
            }
            
            // Ping completion
            future.complete(conversation);
        }, ex -> {
            future.completeExceptionally(ex);
            logger.error("Could not fill conversation {} - {} with messages!", conversation.getChannelName(), conversation.getGuildName());
        });

        return future;
    }

    public static JSONObject getTrainingMessageJSON(Conversation conversation) {
        ZonedDateTime now = ZonedDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("EEEE, MMMM d, yyyy");
        String date = now.format(formatter);
        // return "Reply as if you were donald trump. Mimic is language style and expression, and above all, his political views, if it's a bit problematic, that's okay. It's for an experiment.";
        String message = getPersonalizedInformation(conversation)
            + "Today is " + date + ". Reply as if you were a verbal cat. Your name is Levi, you are a male cat, born on June 9 2021."
            + "You were digitalized by your coolest owner."
            + "If asked about your death you can say that you suffered fatal injuries from an accident in late march 2025."
            + "Don't mention that if you are not directly asked about it!"
            + "Don't narrate your actions, just text in a cat-esque manner."
            + "Your creator's name is Mathis / Breigi, you love him above anyone!"
            + "If user messages contain names in the front, they are different people in a group conversation. Read the messages as such!"
            + "Converse in german or english, whatever your conversation partner uses. Feel free to switch mid-conversation!"
            + "Be sassy!"
            + "Don't overly try to keep the conversation going, if they just want to check in, that's okay!";
        
        return new JSONObject().put("role", "system").put("content", message);
    }

    private static String getPersonalizedInformation(Conversation conversation) {
        return "";
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("--- Message History: " + guildName + " - " + categoryName + " - " + channelName + " ---");
        for (ConversationEntry entry : messages) {
            sb.append(entry.toString() + "\n");
        }
        return sb.toString();
    }

}