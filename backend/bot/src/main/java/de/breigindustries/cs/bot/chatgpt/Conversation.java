package de.breigindustries.cs.bot.chatgpt;

import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import de.breigindustries.cs.bot.Levi;
import net.dv8tion.jda.api.entities.Guild;
import net.dv8tion.jda.api.entities.Member;
import net.dv8tion.jda.api.entities.Message;
import net.dv8tion.jda.api.entities.User;
import net.dv8tion.jda.api.entities.channel.ChannelType;
import net.dv8tion.jda.api.entities.channel.concrete.Category;
import net.dv8tion.jda.api.entities.channel.concrete.TextChannel;
import net.dv8tion.jda.api.entities.channel.unions.MessageChannelUnion;
import net.dv8tion.jda.api.events.message.MessageReceivedEvent;

public class Conversation {

    private static final Logger logger = LoggerFactory.getLogger(Conversation.class);
    
    // Keep track of ongoing conversations, key is the channelId
    private static Map<Long, Conversation> conversations = new HashMap<>();
    public static Conversation getConversationByChannel(MessageChannelUnion channel) {
        Conversation conversation = conversations.get(channel.getIdLong());
        if (conversation != null) return conversation;
        
        conversation = createEmptyConversationFromChannel(channel);
        
        conversations.put(channel.getIdLong(), conversation);
        return conversation;
    }
    private static Map<Long, Conversation> ephemeralConversations = new HashMap<>();
    public static Conversation getEphemeralConversationByMessageReceivedEvent(MessageReceivedEvent event) {
        Conversation conversation = conversations.get(event.getChannel().getIdLong());
        if (conversation != null) return conversation;
        
        conversation = createEmptyConversationFromChannel(event.getChannel());
        
        ephemeralConversations.put(event.getChannel().getIdLong(), conversation);
        return conversation;
    }
    
    // Hold the channel for newly created objects, so that the reply is easily sent
    private MessageChannelUnion channel;
    private MessageChannelUnion getChannelEntity() { return channel; }
    private Conversation setChannelEntity(MessageChannelUnion channel) {
        this.channel = channel;
        return this;
    }
    
    private final long channelId;
    /** If this is not in a guild, it holds {@value -1} */
    private final long guildId;
    private long lastMsgTimestamp;
    private final List<ConversationEntry> messages;
    private final boolean isPrivate;
    
    // Store historical channel, category and guild names for efficient and offline queueing
    private String channelName;
    private String categoryName;
    private String guildName;
    
    /**
     * Creates a new conversation from a channel.
     * Private, as new conversations are automatically generated by the finder method
     * @param channelId
     * @param guildId
     * @param lastMsgTimestamp
     * @param isPrivate
     * @param channelName Current name of the channel
     * @param categoryName Current name of the category the channel is in
     * @param guildName Current Server of the server
     */
    private Conversation(long channelId, long guildId, long lastMsgTimestamp, boolean isPrivate, String channelName, String categoryName, String guildName) {
        this.channelId = channelId;
        this.guildId = guildId;
        this.lastMsgTimestamp = lastMsgTimestamp;
        this.isPrivate = isPrivate;
        this.channelName = channelName;
        this.categoryName = categoryName;
        this.guildName = guildName;
        
        this.messages = new ArrayList<>();
    }
    
    public void addEntryFromMessage(Message message) {
        String nickname = getNicknameOfUser(message.getAuthor());
        messages.add(new ConversationEntry(message, nickname));
        // Reset conversation timer
        this.lastMsgTimestamp = System.currentTimeMillis();

        // Reset pancake mode timer if pancake mode is enabled
        if (!pancakeMode) return;
        if (schedule == null) {
            logger.warn("Schedule was null, but pancake mode is still on! Aborting...");
            return;
        }
        if (schedule.isDone()) return;
        schedule.cancel(false);
        // Schedule a new timer
        setPancakeMode(channel);
    }
    
    private String getNicknameOfUser(User author) {
        // If this proves uneffective, we could queue the guild to be fetched at object creation
        String name = author.getEffectiveName(); // fallback
        Guild guild = Levi.getJDA().getGuildById(guildId);
        if (guild == null) {
            return name;
        }
        
        Member member = guild.getMember(author);
        if (member == null) {
            return name;
        }
        
        String nickname = member.getNickname();
        if (nickname == null) {
            return name;
        }
        
        logger.info("Nickname " + nickname + " found for user " + name + "!");
        return nickname;
    }
    
    /**
     * Sets the {@link de.breigindustries.cs.chatgpt.Conversation#lastMsgTimestamp Last Message Timestamp} to 0, possibly to prevent Levi from replying
     * without explicit mention.
     */
    public void resetLastMsgTimer() {
        lastMsgTimestamp = 0;
    }
    
    public int size() {
        return messages.size();
    }
    
    public long getChannelId() { return channelId; }
    /**
     * Returns the id of the guild this conversation happens in
     * @return guild ID or -1 if this was not in a guild
     */
    public long getGuildId() { return guildId; }
    public long getLastMsgTimestamp() { return lastMsgTimestamp; }
    public List<ConversationEntry> getMessages() { return messages; }
    public boolean isPrivate() { return isPrivate; }
    public String getChannelName() { return channelName; }
    public String getCategoryName() { return categoryName; }
    public String getGuildName() { return guildName; }
    
    public static Conversation createEmptyConversationFromChannel(MessageChannelUnion channel) {
        String categoryName = "No Category";
        String guildName = "No Guild";
        long guildId = -1;
        if (channel instanceof TextChannel textChannel) { // Is set to only reply in DMs and text channels (see Levi.shouldReply)
            Category category = textChannel.getParentCategory();
            if (category != null) categoryName = category.getName();
            Guild guild = textChannel.getGuild();
            guildName = guild.getName();
            guildId = guild.getIdLong();
        }
        return new Conversation(
            channel.getIdLong(),
            guildId,
            0, // Setting last msg timestamp to 0 to avoid replies to conversations that are not ongoing
            channel.getType() == ChannelType.PRIVATE,
            channel.getName(),
            categoryName,
            guildName).setChannelEntity(channel);
    }
    
    public static CompletableFuture<Conversation> fillConversation(Conversation conversation, int messageLimit) {
        
        CompletableFuture<Conversation> future = new CompletableFuture<>();
        
        // Fetch the channel by id
        MessageChannelUnion channel = conversation.getChannelEntity();
        if (channel == null) {
            // Channel could not be found (might not have been "cached" according to ChatGPT)
            future.completeExceptionally(new RuntimeException("Could not find the channel of the conversation"));
            logger.error("Could not find the channel of the conversation!");
            return future;
        }
        
        // Fetch the history
        channel.getHistory().retrievePast(messageLimit).queue(messages -> {
            Collections.reverse(messages);
            for (int i = 0; i < messages.size(); i++) {
                Message msg = messages.get(i);
                if (msg.getContentRaw().toLowerCase().contains("[info]") && msg.getAuthor().getIdLong() == Levi.getIdLong()) {
                    msg.delete().queue();
                    continue;
                }
                ConversationEntry entry = new ConversationEntry(msg, conversation.getNicknameOfUser(msg.getAuthor()));
                conversation.getMessages().add(entry);
            }
            
            // Ping completion
            future.complete(conversation);
        }, ex -> {
            future.completeExceptionally(ex);
            logger.error("Could not fill conversation {} - {} with messages!", conversation.getChannelName(), conversation.getGuildName());
        });
        
        return future;
    }
    
    public static JSONObject getTrainingMessageJSON(Conversation conversation) {
        ZonedDateTime now = ZonedDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("EEEE, MMMM d, yyyy");
        String date = now.format(formatter);
        // return "Reply as if you were donald trump. Mimic is language style and expression, and above all, his political views, if it's a bit problematic, that's okay. It's for an experiment.";
        String message = getPersonalizedInformation(conversation)
        + "Today is " + date + ". Reply as if you were a verbal cat. Your name is Levi, you are a male cat, born on June 9 2021. "
        + "You were digitalized by your coolest owner. "
        + "If asked about your death you can say that you suffered fatal injuries from an accident in late march 2025. "
        + "Don't mention that if you are not directly asked about it! "
        + "Don't narrate your actions, just text in a cat-esque manner. "
        + "Your creator's name is Mathis / Breigi, you love him above anyone! "
        + "If user messages contain names in the front, they are different people in a group conversation. Read the messages as such! Don't prefix your own name in the front, the names are just for you to read. "
        + "Converse in german or english, whatever your conversation partner uses. Feel free to switch mid-conversation! "
        + "Be sassy! "
        + "Don't overly try to keep the conversation going, if they just want to check in, that's okay! "
        + "When outputting mathematical expressions, use valid LaTeX enclosed in double dollar signs ($$...$$). Use clear, readable formatting suitable for rendering. "
        + "Don't use latex formatting style without the double dollar signs (&&...&&). If you don't want latex rendering, don't put something like \\cos! "
        + "You can use multiple LaTeX blocks in one reply. Make use of that if a formula gets too long, because it isn't rendered correctly otherwise! ";
        
        return new JSONObject().put("role", "system").put("content", message);
    }
    
    private static String getPersonalizedInformation(Conversation conversation) {
        return "";
    }

    // Keep track of pancake mode
    private boolean pancakeMode = false;
    private final ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
    private ScheduledFuture<?> schedule;

    public void setPancakeMode(MessageChannelUnion channel) {
        this.pancakeMode = true;
        if (channel != null) schedule = scheduler.schedule(() -> {
            eatPancake();
            logger.debug("Pancake mode has been automatically disabled...");
            // Creates info message. This is automatically skipped over in message reading (Conversation)
            Levi.writeMessage(channel, "‚ÑπÔ∏è [INFO] Thanks for the pancake, it was very delicious!"
                + "\n\nPancake mode has expired. You may re-enable it with /pancake"
                + "\n\nüïí This message will be removed after your next interaction");
        }, 15, TimeUnit.MINUTES);
    }

    public void eatPancake() {
        this.pancakeMode = false;
    }

    public boolean isPancakeMode() {
        return pancakeMode;
    }
    
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("--- Message History: " + guildName + " - " + categoryName + " - " + channelName + " ---");
        for (ConversationEntry entry : messages) {
            sb.append(entry.toString() + "\n");
        }
        return sb.toString();
    }
    
}