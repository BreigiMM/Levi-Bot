package de.breigindustries.cs.chatgpt;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import de.breigindustries.cs.Levi;
import net.dv8tion.jda.api.entities.Guild;
import net.dv8tion.jda.api.entities.Member;
import net.dv8tion.jda.api.entities.Message;
import net.dv8tion.jda.api.entities.User;
import net.dv8tion.jda.api.entities.channel.ChannelType;
import net.dv8tion.jda.api.entities.channel.concrete.Category;
import net.dv8tion.jda.api.entities.channel.concrete.TextChannel;
import net.dv8tion.jda.api.entities.channel.unions.MessageChannelUnion;
import net.dv8tion.jda.api.events.message.MessageReceivedEvent;

public class Conversation {

    private static final Logger logger = LoggerFactory.getLogger(Conversation.class);

    // Keep track of ongoing conversations, key is the channelId
    private static Map<Long, Conversation> conversations = new HashMap<>();
    public static Conversation getConversationByMessageReceivedEvent(MessageReceivedEvent event) {
        Conversation conversation = conversations.get(event.getChannel().getIdLong());
        if (conversation != null) return conversation;

        conversation = createEmptyConversationFromMessageReceivedEvent(event);
        
        conversations.put(event.getChannel().getIdLong(), conversation);
        return conversation;
    }

    // Hold the channel for new objects
    private MessageChannelUnion channel;
    private MessageChannelUnion getChannelEntity() { return channel; }
    private Conversation setChannelEntity(MessageChannelUnion channel) {
        this.channel = channel;
        return this;
    }

    private final long channelId;
    /** If this is not in a guild, it holds {@value -1} */
    private final long guildId;
    private long lastMsgTimestamp;
    private final List<ConversationEntry> messages;
    private final boolean isPrivate;

    // Store historical channel, category and guild names for efficient and offline queueing
    private String channelName;
    private String categoryName;
    private String guildName;

    /**
     * Creates a new conversation from a channel.
     * Private, as new conversations are automatically generated by the finder method
     * @param channelId
     * @param guildId
     * @param lastMsgTimestamp
     * @param isPrivate
     * @param channelName Current name of the channel
     * @param categoryName Current name of the category the channel is in
     * @param guildName Current Server of the server
     */
    private Conversation(long channelId, long guildId, long lastMsgTimestamp, boolean isPrivate, String channelName, String categoryName, String guildName) {
        this.channelId = channelId;
        this.guildId = guildId;
        this.lastMsgTimestamp = lastMsgTimestamp;
        this.isPrivate = isPrivate;
        this.channelName = channelName;
        this.categoryName = categoryName;
        this.guildName = guildName;

        this.messages = new ArrayList<>();
    }

    public void addEntryFromMessage(Message message) {
        String nickname = getNicknameOfUser(message.getAuthor());
        messages.add(new ConversationEntry(message, nickname));
    }

    private String getNicknameOfUser(User author) {
        // If this proves uneffective, we could queue the guild to be fetched at object creation
        String name = author.getEffectiveName(); // fallback
        Guild guild = Levi.getJDA().getGuildById(guildId);
        if (guild == null) {
            return name;
        }

        Member member = guild.getMember(author);
        if (member == null) {
            return name;
        }

        String nickname = member.getNickname();
        if (nickname == null) {
            return name;
        }

        logger.info("Nickname " + nickname + " found for user " + name + "!");
        return nickname;
    }

    /**
     * Sets the {@link de.breigindustries.cs.chatgpt.Conversation#lastMsgTimestamp Last Message Timestamp} to 0, possibly to prevent Levi from replying
     * without explicit mention.
     */
    public void resetLastMsgTimer() {
        lastMsgTimestamp = 0;
    }

    public int size() {
        return messages.size();
    }

    public long getChannelId() { return channelId; }
    /**
     * Returns the id of the guild this conversation happens in
     * @return guild ID or -1 if this was not in a guild
     */
    public long getGuildId() { return guildId; }
    public long getLastMsgTimestamp() { return lastMsgTimestamp; }
    public List<ConversationEntry> getMessages() { return messages; }
    public boolean isPrivate() { return isPrivate; }
    public String getChannelName() { return channelName; }
    public String getCategoryName() { return categoryName; }
    public String getGuildName() { return guildName; }

    public static Conversation createEmptyConversationFromMessageReceivedEvent(MessageReceivedEvent event) {
        MessageChannelUnion channel = event.getChannel();
        String categoryName = "No Category";
        String guildName = "No Guild";
        long guildId = -1;
        if (channel instanceof TextChannel textChannel) { // Is set to only reply in DMs and text channels (see Levi.shouldReply)
            Category category = textChannel.getParentCategory();
            if (category != null) categoryName = category.getName();
            Guild guild = event.getGuild();
            guildName = guild.getName();
            guildId = guild.getIdLong();
        }
        return new Conversation(
            channel.getIdLong(),
            guildId,
            System.currentTimeMillis(),
            channel.getType() == ChannelType.PRIVATE,
            channel.getName(),
            categoryName,
            guildName).setChannelEntity(channel);
    }

    public static CompletableFuture<Conversation> fillConversation(Conversation conversation, int messageLimit) {
        
        CompletableFuture<Conversation> future = new CompletableFuture<>();
        
        // Fetch the channel by id
        MessageChannelUnion channel = conversation.getChannelEntity();
        if (channel == null) {
            // Channel could not be found (might not have been "cached" according to ChatGPT)
            future.completeExceptionally(new RuntimeException("Could not find the channel of the conversation"));
            logger.error("Could not find the channel of the conversation!");
            return future;
        }

        // Fetch the history
        channel.getHistory().retrievePast(messageLimit).queue(messages -> {
            List<Message> reversedMessages = messages.reversed();
            for (int i = 0; i < reversedMessages.size(); i++) {
                Message msg = reversedMessages.get(i);
                ConversationEntry entry = new ConversationEntry(msg, conversation.getNicknameOfUser(msg.getAuthor()));
                conversation.getMessages().add(entry);
            }
            
            // Ping completion
            future.complete(conversation);
        }, future::completeExceptionally);

        return future;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("--- Message History: " + guildName + " - " + categoryName + " - " + channelName + " ---");
        for (ConversationEntry entry : messages) {
            sb.append(entry.toString() + "\n");
        }
        return sb.toString();
    }

}